## C盘权限目录开启

net2-1  41分钟

## 修改C字体大小

net2-2  24分钟

# **第一讲、****VIVADO** **安装和** **ZYNQ** **系列芯片发展应用前景**

仿真文件路径存放位置：

![image-20231201103527026](H:/typora%E5%9B%BE%E7%89%87/image-20231201103527026.png)

# **第二讲、****Zynq** **开发知识储备和** **C** **语言基础**

芯片型号

![image-20231201111924942](H:/typora%E5%9B%BE%E7%89%87/image-20231201111924942.png)

![image-20231201153006967](H:/typora%E5%9B%BE%E7%89%87/image-20231201153006967.png)

 ![image-20231201153029300](H:/typora%E5%9B%BE%E7%89%87/image-20231201153029300.png)

![image-20231201153058653](H:/typora%E5%9B%BE%E7%89%87/image-20231201153058653.png)

![image-20231201153115145](H:/typora%E5%9B%BE%E7%89%87/image-20231201153115145.png)

 ![image-20231201153139091](H:/typora%E5%9B%BE%E7%89%87/image-20231201153139091.png)

不需要绑定管脚

![image-20231201154718271](H:/typora%E5%9B%BE%E7%89%87/image-20231201154718271.png)

![image-20231201154923398](H:/typora%E5%9B%BE%E7%89%87/image-20231201154923398.png)

![image-20231201154931713](H:/typora%E5%9B%BE%E7%89%87/image-20231201154931713.png)

生成所有IP所需要的文件

![image-20231201155042157](H:/typora%E5%9B%BE%E7%89%87/image-20231201155042157.png)

global：将block design 设计的文件都生成到工程中 

out of context per IP：按照每个IP的文件生成。在综合的时候按照每个IP生成一个网表。将网表综合到一块。

优点：在选择完成后，不需要点击```run synthesis```，就会综合网表。



![image-20231201155735162](H:/typora%E5%9B%BE%E7%89%87/image-20231201155735162.png)

综合和布局布线所占用的线程数量。



综合生成的网表

![image-20231201160234060](H:/typora%E5%9B%BE%E7%89%87/image-20231201160234060.png)

bit文件

![image-20231201160345123](H:/typora%E5%9B%BE%E7%89%87/image-20231201160345123.png)

接下来生成软件开发包的硬件表述文件

![image-20231201160750801](H:/typora%E5%9B%BE%E7%89%87/image-20231201160750801.png)

![image-20231201160823083](H:/typora%E5%9B%BE%E7%89%87/image-20231201160823083.png)

压缩包文件，描述硬件资源有哪些压缩包可以用。开发时如何调用官方给的驱动。

有了这个才可以创建软件开发的工程。

打开

![image-20231201161201122](H:/typora%E5%9B%BE%E7%89%87/image-20231201161201122.png)

```system.hdf```所有硬件的地址范围。

## 创建一个C语言的工程

![image-20231201170741032](H:/typora%E5%9B%BE%E7%89%87/image-20231201170741032.png)

选择hello world模板

![image-20231201170803882](H:/typora%E5%9B%BE%E7%89%87/image-20231201170803882.png)

查看打印信息

![image-20231201171006565](H:/typora%E5%9B%BE%E7%89%87/image-20231201171006565.png)

```.elf```是arm的可执行文件

### 连接板子

查看设备管理器的驱动

装x64的驱动

![image-20231201171400157](H:/typora%E5%9B%BE%E7%89%87/image-20231201171400157.png)

![image-20231201171448995](H:/typora%E5%9B%BE%E7%89%87/image-20231201171448995.png)

连接串口，点击+号

![image-20231201171546876](H:/typora%E5%9B%BE%E7%89%87/image-20231201171546876.png)

![image-20231201171624757](H:/typora%E5%9B%BE%E7%89%87/image-20231201171624757.png)

![image-20231201171647766](H:/typora%E5%9B%BE%E7%89%87/image-20231201171647766.png)

### 运行文件，单步调试

![image-20231201171730374](H:/typora%E5%9B%BE%E7%89%87/image-20231201171730374.png)

![image-20231201171757449](H:/typora%E5%9B%BE%E7%89%87/image-20231201171757449.png)

 最上边最右边

![image-20231201171832482](H:/typora%E5%9B%BE%E7%89%87/image-20231201171832482.png)

C/C++编辑模式，dubug模式。切换到编辑模式

下载fpga的配置。

![image-20231201171922290](H:/typora%E5%9B%BE%E7%89%87/image-20231201171922290.png)

###    program方法2：

![image-20231201172130710](H:/typora%E5%9B%BE%E7%89%87/image-20231201172130710.png)

![image-20231201172216750](H:/typora%E5%9B%BE%E7%89%87/image-20231201172216750.png)

CPU正常的话停在main函数的第一行。

program之后。

### 调试

![image-20231201172826439](H:/typora%E5%9B%BE%E7%89%87/image-20231201172826439.png)

step over：单步运行

step into：进到函数里面

step return：跳出函数。

![image-20231201172922154](H:/typora%E5%9B%BE%E7%89%87/image-20231201172922154.png)

resume：一直往下运行，直到到达断点。

在hello处设置断点，切换到

![image-20231201173110154](H:/typora%E5%9B%BE%E7%89%87/image-20231201173110154.png)

再往下执行一步，查看是否会出现结果。

![image-20231201173155797](H:/typora%E5%9B%BE%E7%89%87/image-20231201173155797.png)

### 不用sdk terminal的方法

（串口助手和sdk terminal只能用一个）

点击×号

![image-20231201173242190](H:/typora%E5%9B%BE%E7%89%87/image-20231201173242190.png)

断开当前连接

![image-20231201173324945](H:/typora%E5%9B%BE%E7%89%87/image-20231201173324945.png)

打开串口调试助手，

再重新跑一遍，![image-20231201173701817](H:/typora%E5%9B%BE%E7%89%87/image-20231201173701817.png)

选择第一个调试方法

因为刚才已经配置过了，所以可以选择第一个。

![image-20231201173422169](H:/typora%E5%9B%BE%E7%89%87/image-20231201173422169.png)

![image-20231201173857777](H:/typora%E5%9B%BE%E7%89%87/image-20231201173857777.png)

## C语言基础

此时可以打开 SDK 进行软件开发，按照下图启动 SDK，launch sdk

![image-20231201200307404](H:/typora%E5%9B%BE%E7%89%87/image-20231201200307404.png)

新建一个项目

![image-20231201200525591](H:/typora%E5%9B%BE%E7%89%87/image-20231201200525591.png)

![image-20231201200544139](H:/typora%E5%9B%BE%E7%89%87/image-20231201200544139.png)

![image-20231201200631501](H:/typora%E5%9B%BE%E7%89%87/image-20231201200631501.png)

![image-20231201200639645](H:/typora%E5%9B%BE%E7%89%87/image-20231201200639645.png)

###  int 类型

只要$<2^32=4,294,967,296$都可以用32位表示。

在声明中 ***** 是用来指定一个变量是指针

```c
查看这段代码，*ip 就相当于从ip这个地址中取值。
所以单纯的ip就是地址的值
    
    ip：地址
    *ip:地址中存放的值/* 指针变量的声明 */
   
    var：值/* 实际变量的声明 */
    &var：值对应的地址
#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("var 变量的地址: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("ip 变量存储的地址: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("*ip 变量的值: %d\n", *ip );
 
   return 0;
}
var 变量的地址: 0x7ffeeef168d8
ip 变量存储的地址: 0x7ffeeef168d8
*ip 变量的值: 20

```



在其它中 一元运算符 ***** 来返回位于操作数所指定地址的变量的值

```c
ALT+?自动补全
每两个数代表一个字节，一个字节是8位。所以下面都是4字节，代表32位
int main()
{
    int * RegPtr;//指向地址的变量
    //给地址初始化
    RegPtr = (int *)0x1000000;//强制类型转换 
	//初始化地址中的数据
    * RegPtr=0x000000ff; 
}
```

点击保存，查看内存中的数据。

连接好板卡后

![image-20231201203208317](H:/typora%E5%9B%BE%E7%89%87/image-20231201203208317.png)

双击创建一个新的C程序

![image-20231201203401980](H:/typora%E5%9B%BE%E7%89%87/image-20231201203401980.png)

![image-20231201203421941](H:/typora%E5%9B%BE%E7%89%87/image-20231201203421941.png)

-> debug

->YES

查看地址是否填充了数据

![image-20231201203519701](H:/typora%E5%9B%BE%E7%89%87/image-20231201203519701.png)

运行程序，检测变化

![image-20231201203548668](H:/typora%E5%9B%BE%E7%89%87/image-20231201203548668.png)

### 作业：写char类型的。

地址还是32位，但是数据只能写8位。

### struct类型

#### 自动分配地址

```c
struct REGLIST{//结构体 结构体变量名称
    int index;
    char buffer[4]; 
}reg1; //REGLIST的名称
reg1.index=0x01;
reg1.buffer[0]=0x01;
reg1.buffer[1]=0x02;
reg1.buffer[2]=0x03;
reg1.buffer[3]=0x04;
```

上面也是一段内存，如何看数据？

![image-20231201210143390](H:/typora%E5%9B%BE%E7%89%87/image-20231201210143390.png)

右上角有变量信息

![image-20231201210528159](H:/typora%E5%9B%BE%E7%89%87/image-20231201210528159.png) 

查看第一个变量地址

![image-20231201210449746](H:/typora%E5%9B%BE%E7%89%87/image-20231201210449746.png)

添加地址 0x10c020

![image-20231201210554142](H:/typora%E5%9B%BE%E7%89%87/image-20231201210554142.png)

==index是int类型，占32位，4个字节==

==char类型占8位，一个字节，所以buffer占4-7这四个字节。==

![image-20231201210741386](H:/typora%E5%9B%BE%E7%89%87/image-20231201210741386.png)

#### 手动分配地址

```c
struct REGLIST (
	int index;
    char buffer[4];
);
struct REGLIST * RegPtr;//用结构体类型 声明了一个指针变量，而不是结构体名字去声明
RegPtr=(struct REGLIST *) 0x100000;
// -> 访问内部成员变量
RegPtr->index=0x01;	
RegPtr->buffer[0]=0x02;
RegPtr->buffer[1]=0x03;
RegPtr->buffer[2]=0x04;
RegPtr->buffer[3]=0x05;
```

```c
	//不是这么写
//错误1
	struct REGLIST (
	int index;
    char buffer[4];
);
struct REGLIST * RegPtr;//用结构体类型 声明了一个指针变量，而不是结构体名字去声明
RegPtr=(struct REGLIST *) 0x100000;
//错误2
	RegPtr->reg2.index=0x02;
	RegPtr->reg2.buffer[0]=0x03;
	RegPtr->reg2.buffer[1]=0x04;
	RegPtr->reg2.buffer[2]=0x05;
	RegPtr->reg2.buffer[3]=0x06;
```

![image-20231202171804266](H:/typora%E5%9B%BE%E7%89%87/image-20231202171804266.png)

### sizeof

![image-20231201214619382](H:/typora%E5%9B%BE%E7%89%87/image-20231201214619382.png)

### 函数声明

程序自上而下执行，在main函数下面声明函数时，需要在main函数上面定义一下。

main函数在指定的地址中赋值，testfunc函数将地址中的值拿出来作比较

```c
int testFunc();

int main()
{
	//TEST5 if else 直接在地址中赋值，并用函数取出地址中的值
	char *RegPtr;
	RegPtr = (char *)0x1000000;
	//0x1000000这个地址中的值为0xff
	*RegPtr=0xff;
	testFunc();
	print("Hello World \n \r");
	return 0;
}

//取地址* ReadRegPtr中的值FlagReg，并查看是否=0xff
//是的话用WriteFlag输出01，否则输出00
int testFunc(){
	char FlagReg,WriteFlag;
	char * ReadRegPtr;
	ReadRegPtr=(char *)0x1000000;
	FlagReg=*ReadRegPtr;//取ReadRegPtr这个地址中的值
	if (FlagReg==0xff){
		WriteFlag=0x01;
		printf("WriteFlag is %d \n",WriteFlag);
	}
	else {
		WriteFlag=0x00;
		printf("WriteFlag is %d \n",WriteFlag);
	}
}

```



### SDK崩溃后无法运行C代码

打开后还是有错误

![image-20231201221721780](H:/typora%E5%9B%BE%E7%89%87/image-20231201221721780.png)

恢复工程

删掉下面的以及```SDK.log```

![image-20231201221054889](H:/typora%E5%9B%BE%E7%89%87/image-20231201221054889.png)

![image-20231201221322726](H:/typora%E5%9B%BE%E7%89%87/image-20231201221322726.png)

在窗口的文件里面找到这个工具

![image-20231201221938492](H:/typora%E5%9B%BE%E7%89%87/image-20231201221938492.png)

将工程设置到SDK里面

![image-20231201222033702](H:/typora%E5%9B%BE%E7%89%87/image-20231201222033702.png)

导入工程

![image-20231201222137468](H:/typora%E5%9B%BE%E7%89%87/image-20231201222137468.png)

![image-20231201222151982](H:/typora%E5%9B%BE%E7%89%87/image-20231201222151982.png)

导入刚刚SDK的目录

![image-20231201222231480](H:/typora%E5%9B%BE%E7%89%87/image-20231201222231480.png)

-> finish

![image-20231201222324686](H:/typora%E5%9B%BE%E7%89%87/image-20231201222324686.png)

不要忘记 打开串口

## case break;

```c
int main(){
    char *RegPtr;
	RegPtr = (char *)0x1000000;
	//0x1000000这个地址中的值为0xff
	*RegPtr=0xff;
	testcaseFunc();
	print("Hello World \n \r");
return 0;
}
}

int testcaseFunc(){
	char FlagReg,WriteFlag;//地址中的值，输出的值
	char *ReadRegPtr;
	ReadRegPtr=(char *)0x1000000;
	FlagReg=*ReadRegPtr;
	switch (FlagReg){
	case 0xff:WriteFlag=0x01;break;
	case 0x00:WriteFlag=0x02;break;
	deaflut:WriteFlag=0x00;
	}
	printf("WriteFlag is %d \n",WriteFlag);
}

```



## for

```c
int main(){
    int i;
	for (i=0;i<10;i++){
		printf("%d \n",i);
	}
	return 0;
}
```



## do while 

```c
do
{
   statement(s);

}while( condition );
```

```c
#include <stdio.h>
 
int main ()
{
   /* 局部变量定义 */
   int a = 10;

   /* do 循环执行，在条件被测试之前至少执行一次 */
   do
   {
       printf("a 的值： %d\n", a);
       a = a + 1;
   }while( a < 20 );
 
   return 0;
}
```

```c#
a 的值： 10
a 的值： 11
a 的值： 12
a 的值： 13
a 的值： 14
a 的值： 15
a 的值： 16
a 的值： 17
a 的值： 18
a 的值： 19
```

500  ms。

这是以us为单位的。

```c
	int i=0;
	while(1){
		printf("%d \n",i);
		i++;
		usleep(500000);
		if (i>=50){
			return;
		}
	}
	return 0;
```

## 作业1

代码1：两个for循环，复杂度大

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

void printPic();
int main()
{
    init_platform();
    printPic();
    print("Hello World\n\r");

    cleanup_platform();
    return 0;
}
void printPic(){
	int a;
	int i;
	int row=1;
	do{

		if (row==1||row==4){
				for(i=0;i<60;i++){
					printf("*");
				}
				printf("\n");
				row++;
			}
			if (row==2||row==3){
				a=1;

				for (;a<=60;a++){
					if (a==1||a==29||a==60){
						printf("*");
					}else {
						printf("_");
					}
				}
				printf("\n");
				row++;
			}
	}while(row<=4);

}
```

```c
************************************************************
*___________________________*______________________________*
*___________________________*______________________________*
************************************************************
Hello World
```

代码2  一个for循环

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

void printPic();
int main()
{
    init_platform();
    printPic();
    print("Hello World\n\r");

    cleanup_platform();
    return 0;
}
void printPic(){
	int i;
	int row=1;
	do{
		for(i=0;i<60;i++){
			if (row==1||row==4){
						printf("*");
				if (i==59){
					printf("\n");
					row++;
				}
				}
		else if (row==2||row==3){
					if (i==0||i==30||i==59){
						printf("*");
					}else {
						printf("_");
					}
					if (i==59){
						printf("\n");
						row++;
					}
			}
		}
	}while(row<=4);
}

```

作业2

一个 int 类型的 buffer 深度为 1024 需要初始化为从 1023 到 0 的递减数据，起始数据为 1023；另外一个 char 类型的 buffer 深度为 256，需要初始化为 0 到255 递增数据，起始数据为 0，请使用一个 for 循环初始化两个 buffer；

```c
void initBuffers(){
	int buffer1[1024];
	char buffer2[256];
	int i;
	for (i=0;i<1024;i++){
		buffer1[1023-i]=i;
		if (i<256){
			buffer2[i]=i;
		}
		printf("buffer1024[%d] is %d \n",(1023-i),buffer1[1023-i]);
	}

	for (i=0;i<256;i++){
		printf("buffer256[%d] is %d \n",i,buffer2[i]);
	}

}
```

