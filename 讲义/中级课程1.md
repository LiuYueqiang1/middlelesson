## C盘权限目录开启

net2-1  41分钟

## 修改C字体大小

net2-2  24分钟

# **第一讲、****VIVADO** **安装和** **ZYNQ** **系列芯片发展应用前景**

仿真文件路径存放位置：

![image-20231201103527026](H:/typora%E5%9B%BE%E7%89%87/image-20231201103527026.png)

# **第二讲、****Zynq** **开发知识储备和** **C** **语言基础**

芯片型号

![image-20231201111924942](H:/typora%E5%9B%BE%E7%89%87/image-20231201111924942.png)

![image-20231201153006967](H:/typora%E5%9B%BE%E7%89%87/image-20231201153006967.png)

 ![image-20231201153029300](H:/typora%E5%9B%BE%E7%89%87/image-20231201153029300.png)

![image-20231201153058653](H:/typora%E5%9B%BE%E7%89%87/image-20231201153058653.png)

![image-20231201153115145](H:/typora%E5%9B%BE%E7%89%87/image-20231201153115145.png)

 ![image-20231201153139091](H:/typora%E5%9B%BE%E7%89%87/image-20231201153139091.png)

不需要绑定管脚

![image-20231201154718271](H:/typora%E5%9B%BE%E7%89%87/image-20231201154718271.png)

![image-20231201154923398](H:/typora%E5%9B%BE%E7%89%87/image-20231201154923398.png)

![image-20231201154931713](H:/typora%E5%9B%BE%E7%89%87/image-20231201154931713.png)

生成所有IP所需要的文件

![image-20231201155042157](H:/typora%E5%9B%BE%E7%89%87/image-20231201155042157.png)

global：将block design 设计的文件都生成到工程中 

out of context per IP：按照每个IP的文件生成。在综合的时候按照每个IP生成一个网表。将网表综合到一块。

优点：在选择完成后，不需要点击```run synthesis```，就会综合网表。



![image-20231201155735162](H:/typora%E5%9B%BE%E7%89%87/image-20231201155735162.png)

综合和布局布线所占用的线程数量。



综合生成的网表

![image-20231201160234060](H:/typora%E5%9B%BE%E7%89%87/image-20231201160234060.png)

bit文件

![image-20231201160345123](H:/typora%E5%9B%BE%E7%89%87/image-20231201160345123.png)

接下来生成软件开发包的硬件表述文件

![image-20231201160750801](H:/typora%E5%9B%BE%E7%89%87/image-20231201160750801.png)

![image-20231201160823083](H:/typora%E5%9B%BE%E7%89%87/image-20231201160823083.png)

压缩包文件，描述硬件资源有哪些压缩包可以用。开发时如何调用官方给的驱动。

有了这个才可以创建软件开发的工程。

打开

![image-20231201161201122](H:/typora%E5%9B%BE%E7%89%87/image-20231201161201122.png)

```system.hdf```所有硬件的地址范围。

## 创建一个C语言的工程

![image-20231201170741032](H:/typora%E5%9B%BE%E7%89%87/image-20231201170741032.png)

选择hello world模板

![image-20231201170803882](H:/typora%E5%9B%BE%E7%89%87/image-20231201170803882.png)

查看打印信息

![image-20231201171006565](H:/typora%E5%9B%BE%E7%89%87/image-20231201171006565.png)

```.elf```是arm的可执行文件

### 连接板子

查看设备管理器的驱动

装x64的驱动

![image-20231201171400157](H:/typora%E5%9B%BE%E7%89%87/image-20231201171400157.png)

![image-20231201171448995](H:/typora%E5%9B%BE%E7%89%87/image-20231201171448995.png)

连接串口，点击+号

![image-20231201171546876](H:/typora%E5%9B%BE%E7%89%87/image-20231201171546876.png)

![image-20231201171624757](H:/typora%E5%9B%BE%E7%89%87/image-20231201171624757.png)

![image-20231201171647766](H:/typora%E5%9B%BE%E7%89%87/image-20231201171647766.png)

### 运行文件，单步调试

![image-20231201171730374](H:/typora%E5%9B%BE%E7%89%87/image-20231201171730374.png)

![image-20231201171757449](H:/typora%E5%9B%BE%E7%89%87/image-20231201171757449.png)

 最上边最右边

![image-20231201171832482](H:/typora%E5%9B%BE%E7%89%87/image-20231201171832482.png)

C/C++编辑模式，dubug模式。切换到编辑模式

下载fpga的配置。

![image-20231201171922290](H:/typora%E5%9B%BE%E7%89%87/image-20231201171922290.png)

###    program方法2：

![image-20231201172130710](H:/typora%E5%9B%BE%E7%89%87/image-20231201172130710.png)

![image-20231201172216750](H:/typora%E5%9B%BE%E7%89%87/image-20231201172216750.png)

CPU正常的话停在main函数的第一行。

program之后。

### 调试

![image-20231201172826439](H:/typora%E5%9B%BE%E7%89%87/image-20231201172826439.png)

step over：单步运行

step into：进到函数里面

step return：跳出函数。

![image-20231201172922154](H:/typora%E5%9B%BE%E7%89%87/image-20231201172922154.png)

resume：一直往下运行，直到到达断点。

在hello处设置断点，切换到

![image-20231201173110154](H:/typora%E5%9B%BE%E7%89%87/image-20231201173110154.png)

再往下执行一步，查看是否会出现结果。

![image-20231201173155797](H:/typora%E5%9B%BE%E7%89%87/image-20231201173155797.png)

### 不用sdk terminal的方法

（串口助手和sdk terminal只能用一个）

点击×号

![image-20231201173242190](H:/typora%E5%9B%BE%E7%89%87/image-20231201173242190.png)

断开当前连接

![image-20231201173324945](H:/typora%E5%9B%BE%E7%89%87/image-20231201173324945.png)

打开串口调试助手，

再重新跑一遍，![image-20231201173701817](H:/typora%E5%9B%BE%E7%89%87/image-20231201173701817.png)

选择第一个调试方法

因为刚才已经配置过了，所以可以选择第一个。

![image-20231201173422169](H:/typora%E5%9B%BE%E7%89%87/image-20231201173422169.png)

![image-20231201173857777](H:/typora%E5%9B%BE%E7%89%87/image-20231201173857777.png)

## C语言基础

此时可以打开 SDK 进行软件开发，按照下图启动 SDK，launch sdk

![image-20231201200307404](H:/typora%E5%9B%BE%E7%89%87/image-20231201200307404.png)

新建一个项目

![image-20231201200525591](H:/typora%E5%9B%BE%E7%89%87/image-20231201200525591.png)

![image-20231201200544139](H:/typora%E5%9B%BE%E7%89%87/image-20231201200544139.png)

![image-20231201200631501](H:/typora%E5%9B%BE%E7%89%87/image-20231201200631501.png)

![image-20231201200639645](H:/typora%E5%9B%BE%E7%89%87/image-20231201200639645.png)

###  int 类型

只要$<2^32=4,294,967,296$都可以用32位表示。

在声明中 ***** 是用来指定一个变量是指针

```c
查看这段代码，*ip 就相当于从ip这个地址中取值。
所以单纯的ip就是地址的值
    
    ip：地址
    *ip:地址中存放的值/* 指针变量的声明 */
   
    var：值/* 实际变量的声明 */
    &var：值对应的地址
#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("var 变量的地址: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("ip 变量存储的地址: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("*ip 变量的值: %d\n", *ip );
 
   return 0;
}
var 变量的地址: 0x7ffeeef168d8
ip 变量存储的地址: 0x7ffeeef168d8
*ip 变量的值: 20

```



在其它中 一元运算符 ***** 来返回位于操作数所指定地址的变量的值

```c
ALT+?自动补全
每两个数代表一个字节，一个字节是8位。所以下面都是4字节，代表32位
int main()
{
    int * RegPtr;//指向地址的变量
    //给地址初始化
    RegPtr = (int *)0x1000000;//强制类型转换 
	//初始化地址中的数据
    * RegPtr=0x000000ff; 
}
```

点击保存，查看内存中的数据。

连接好板卡后

![image-20231201203208317](H:/typora%E5%9B%BE%E7%89%87/image-20231201203208317.png)

双击创建一个新的C程序

![image-20231201203401980](H:/typora%E5%9B%BE%E7%89%87/image-20231201203401980.png)

![image-20231201203421941](H:/typora%E5%9B%BE%E7%89%87/image-20231201203421941.png)

-> debug

->YES

查看地址是否填充了数据

![image-20231201203519701](H:/typora%E5%9B%BE%E7%89%87/image-20231201203519701.png)

运行程序，检测变化

![image-20231201203548668](H:/typora%E5%9B%BE%E7%89%87/image-20231201203548668.png)

### 作业：写char类型的。

地址还是32位，但是数据只能写8位。

### struct类型

#### 自动分配地址

```c
struct REGLIST{//结构体 结构体变量名称
    int index;
    char buffer[4]; 
}reg1; //REGLIST的名称
reg1.index=0x01;
reg1.buffer[0]=0x01;
reg1.buffer[1]=0x02;
reg1.buffer[2]=0x03;
reg1.buffer[3]=0x04;
```

上面也是一段内存，如何看数据？

![image-20231201210143390](H:/typora%E5%9B%BE%E7%89%87/image-20231201210143390.png)

右上角有变量信息

![image-20231201210528159](H:/typora%E5%9B%BE%E7%89%87/image-20231201210528159.png) 

查看第一个变量地址

![image-20231201210449746](H:/typora%E5%9B%BE%E7%89%87/image-20231201210449746.png)

添加地址 0x10c020

![image-20231201210554142](H:/typora%E5%9B%BE%E7%89%87/image-20231201210554142.png)

==index是int类型，占32位，4个字节==

==char类型占8位，一个字节，所以buffer占4-7这四个字节。==

![image-20231201210741386](H:/typora%E5%9B%BE%E7%89%87/image-20231201210741386.png)

#### 手动分配地址

```c
struct REGLIST (
	int index;
    char buffer[4];
);
struct REGLIST * RegPtr;//用结构体类型 声明了一个指针变量，而不是结构体名字去声明
RegPtr=(struct REGLIST *) 0x100000;
// -> 访问内部成员变量
RegPtr->index=0x01;	
RegPtr->buffer[0]=0x02;
RegPtr->buffer[1]=0x03;
RegPtr->buffer[2]=0x04;
RegPtr->buffer[3]=0x05;
```

```c
	//不是这么写
//错误1
	struct REGLIST (
	int index;
    char buffer[4];
);
struct REGLIST * RegPtr;//用结构体类型 声明了一个指针变量，而不是结构体名字去声明
RegPtr=(struct REGLIST *) 0x100000;
//错误2
	RegPtr->reg2.index=0x02;
	RegPtr->reg2.buffer[0]=0x03;
	RegPtr->reg2.buffer[1]=0x04;
	RegPtr->reg2.buffer[2]=0x05;
	RegPtr->reg2.buffer[3]=0x06;
```

![image-20231202171804266](H:/typora%E5%9B%BE%E7%89%87/image-20231202171804266.png)

### sizeof

![image-20231201214619382](H:/typora%E5%9B%BE%E7%89%87/image-20231201214619382.png)

### 函数声明

程序自上而下执行，在main函数下面声明函数时，需要在main函数上面定义一下。

main函数在指定的地址中赋值，testfunc函数将地址中的值拿出来作比较

```c
int testFunc();

int main()
{
	//TEST5 if else 直接在地址中赋值，并用函数取出地址中的值
	char *RegPtr;
	RegPtr = (char *)0x1000000;
	//0x1000000这个地址中的值为0xff
	*RegPtr=0xff;
	testFunc();
	print("Hello World \n \r");
	return 0;
}

//取地址* ReadRegPtr中的值FlagReg，并查看是否=0xff
//是的话用WriteFlag输出01，否则输出00
int testFunc(){
	char FlagReg,WriteFlag;
	char * ReadRegPtr;
	ReadRegPtr=(char *)0x1000000;
	FlagReg=*ReadRegPtr;//取ReadRegPtr这个地址中的值
	if (FlagReg==0xff){
		WriteFlag=0x01;
		printf("WriteFlag is %d \n",WriteFlag);
	}
	else {
		WriteFlag=0x00;
		printf("WriteFlag is %d \n",WriteFlag);
	}
}

```



### SDK崩溃后无法运行C代码

打开后还是有错误

![image-20231201221721780](H:/typora%E5%9B%BE%E7%89%87/image-20231201221721780.png)

恢复工程

删掉下面的以及```SDK.log```

![image-20231201221054889](H:/typora%E5%9B%BE%E7%89%87/image-20231201221054889.png)

![image-20231201221322726](H:/typora%E5%9B%BE%E7%89%87/image-20231201221322726.png)

在窗口的文件里面找到这个工具

![image-20231201221938492](H:/typora%E5%9B%BE%E7%89%87/image-20231201221938492.png)

将工程设置到SDK里面

![image-20231201222033702](H:/typora%E5%9B%BE%E7%89%87/image-20231201222033702.png)

导入工程

![image-20231201222137468](H:/typora%E5%9B%BE%E7%89%87/image-20231201222137468.png)

![image-20231201222151982](H:/typora%E5%9B%BE%E7%89%87/image-20231201222151982.png)

导入刚刚SDK的目录

![image-20231201222231480](H:/typora%E5%9B%BE%E7%89%87/image-20231201222231480.png)

-> finish

![image-20231201222324686](H:/typora%E5%9B%BE%E7%89%87/image-20231201222324686.png)

不要忘记 打开串口

## case break;

```c
int main(){
    char *RegPtr;
	RegPtr = (char *)0x1000000;
	//0x1000000这个地址中的值为0xff
	*RegPtr=0xff;
	testcaseFunc();
	print("Hello World \n \r");
return 0;
}
}

int testcaseFunc(){
	char FlagReg,WriteFlag;//地址中的值，输出的值
	char *ReadRegPtr;
	ReadRegPtr=(char *)0x1000000;
	FlagReg=*ReadRegPtr;
	switch (FlagReg){
	case 0xff:WriteFlag=0x01;break;
	case 0x00:WriteFlag=0x02;break;
	deaflut:WriteFlag=0x00;
	}
	printf("WriteFlag is %d \n",WriteFlag);
}

```



## for

```c
int main(){
    int i;
	for (i=0;i<10;i++){
		printf("%d \n",i);
	}
	return 0;
}
```



## do while 

```c
do
{
   statement(s);

}while( condition );
```

```c
#include <stdio.h>
 
int main ()
{
   /* 局部变量定义 */
   int a = 10;

   /* do 循环执行，在条件被测试之前至少执行一次 */
   do
   {
       printf("a 的值： %d\n", a);
       a = a + 1;
   }while( a < 20 );
 
   return 0;
}
```

```c#
a 的值： 10
a 的值： 11
a 的值： 12
a 的值： 13
a 的值： 14
a 的值： 15
a 的值： 16
a 的值： 17
a 的值： 18
a 的值： 19
```

500  ms。

这是以us为单位的。

```c
	int i=0;
	while(1){
		printf("%d \n",i);
		i++;
		usleep(500000);
		if (i>=50){
			return;
		}
	}
	return 0;
```

## 作业1

代码1：两个for循环，复杂度大

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

void printPic();
int main()
{
    init_platform();
    printPic();
    print("Hello World\n\r");

    cleanup_platform();
    return 0;
}
void printPic(){
	int a;
	int i;
	int row=1;
	do{

		if (row==1||row==4){
				for(i=0;i<60;i++){
					printf("*");
				}
				printf("\n");
				row++;
			}
			if (row==2||row==3){
				a=1;

				for (;a<=60;a++){
					if (a==1||a==29||a==60){
						printf("*");
					}else {
						printf("_");
					}
				}
				printf("\n");
				row++;
			}
	}while(row<=4);

}
```

```c
************************************************************
*___________________________*______________________________*
*___________________________*______________________________*
************************************************************
Hello World
```

代码2  一个for循环

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

void printPic();
int main()
{
    init_platform();
    printPic();
    print("Hello World\n\r");

    cleanup_platform();
    return 0;
}
void printPic(){
	int i;
	int row=1;
	do{
		for(i=0;i<60;i++){
			if (row==1||row==4){
						printf("*");
				if (i==59){
					printf("\n");
					row++;
				}
				}
		else if (row==2||row==3){
					if (i==0||i==30||i==59){
						printf("*");
					}else {
						printf("_");
					}
					if (i==59){
						printf("\n");
						row++;
					}
			}
		}
	}while(row<=4);
}

```

## 作业2

一个 int 类型的 buffer 深度为 1024 需要初始化为从 1023 到 0 的递减数据，起始数据为 1023；另外一个 char 类型的 buffer 深度为 256，需要初始化为 0 到255 递增数据，起始数据为 0，请使用一个 for 循环初始化两个 buffer；

```c
void initBuffers(){
	int buffer1[1024];
	char buffer2[256];
	int i;
	for (i=0;i<1024;i++){
		buffer1[1023-i]=i;
		if (i<256){
			buffer2[i]=i;
		}
		printf("buffer1024[%d] is %d \n",(1023-i),buffer1[1023-i]);
	}

	for (i=0;i<256;i++){
		printf("buffer256[%d] is %d \n",i,buffer2[i]);
	}

}
```

# **第三讲、****Zynq** **外设驱动开发之驱动** **IIC** **接口温度传感器**

## 理论部分



![image-20231203155821360](H:/typora%E5%9B%BE%E7%89%87/image-20231203155821360.png)

![image-20231203160439840](H:/typora%E5%9B%BE%E7%89%87/image-20231203160439840.png)

## 实验部分

![image-20231203160659169](H:/typora%E5%9B%BE%E7%89%87/image-20231203160659169.png)

打开vivado

![image-20231203160748722](H:/typora%E5%9B%BE%E7%89%87/image-20231203160748722.png)

![image-20231203160821091](H:/typora%E5%9B%BE%E7%89%87/image-20231203160821091.png)

选择芯片

![image-20231203160842702](H:/typora%E5%9B%BE%E7%89%87/image-20231203160842702.png)

-> finfish

创建block design

![image-20231203161000169](H:/typora%E5%9B%BE%E7%89%87/image-20231203161000169.png)

点击+号，添加zynq

![image-20231203161048677](H:/typora%E5%9B%BE%E7%89%87/image-20231203161048677.png)

双击打开zynq

在PS-PL中，取消RESET0_N

![image-20231203161222633](H:/typora%E5%9B%BE%E7%89%87/image-20231203161222633.png)

![image-20231203161251625](H:/typora%E5%9B%BE%E7%89%87/image-20231203161251625.png)

外设

![image-20231203161323015](H:/typora%E5%9B%BE%E7%89%87/image-20231203161323015.png)

SD0选择40-45

UART0 46-47

I2C0   14-15

![image-20231204104128999](H:/typora%E5%9B%BE%E7%89%87/image-20231204104128999.png)

![image-20231203161524941](H:/typora%E5%9B%BE%E7%89%87/image-20231203161524941.png)

![image-20231203161550222](H:/typora%E5%9B%BE%E7%89%87/image-20231203161550222.png)

DDR configuration

![image-20231203161619550](H:/typora%E5%9B%BE%E7%89%87/image-20231203161619550.png)

![image-20231203161631617](H:/typora%E5%9B%BE%E7%89%87/image-20231203161631617.png)

![image-20231203161803079](H:/typora%E5%9B%BE%E7%89%87/image-20231203161803079.png)

![image-20231203161813483](H:/typora%E5%9B%BE%E7%89%87/image-20231203161813483.png)

![image-20231203161821475](H:/typora%E5%9B%BE%E7%89%87/image-20231203161821475.png)

 点击 ->ok

I2C在FIXED_IO中

![image-20231203161924341](H:/typora%E5%9B%BE%E7%89%87/image-20231203161924341.png)

![image-20231203161944703](H:/typora%E5%9B%BE%E7%89%87/image-20231203161944703.png)

 点击 ->ok

这次仍然没有用到FPGA中PL的管脚。所以不存在绑定管脚的过程。

创建顶层

![image-20231203162154780](H:/typora%E5%9B%BE%E7%89%87/image-20231203162154780.png)

生成bit文件

![image-20231203162222652](H:/typora%E5%9B%BE%E7%89%87/image-20231203162222652.png)

等待几分钟，综合成功点击cancel

![image-20231203162316332](H:/typora%E5%9B%BE%E7%89%87/image-20231203162316332.png)

硬件环境搭建完毕。

![image-20231203162348304](H:/typora%E5%9B%BE%E7%89%87/image-20231203162348304.png)

![image-20231203162355780](H:/typora%E5%9B%BE%E7%89%87/image-20231203162355780.png)

![image-20231203162415096](H:/typora%E5%9B%BE%E7%89%87/image-20231203162415096.png)

 ![image-20231203162523783](H:/typora%E5%9B%BE%E7%89%87/image-20231203162523783.png)

![image-20231203162547093](H:/typora%E5%9B%BE%E7%89%87/image-20231203162547093.png)

![image-20231203162559261](H:/typora%E5%9B%BE%E7%89%87/image-20231203162559261.png)

rename

![image-20231203162702353](H:/typora%E5%9B%BE%E7%89%87/image-20231203162702353.png)

通过下列函数对I2C初始化

![image-20231203163503059](H:/typora%E5%9B%BE%E7%89%87/image-20231203163503059.png)

SDK提供SPI的展示页面，系统中使用的外设显示

![image-20231203163637523](H:/typora%E5%9B%BE%E7%89%87/image-20231203163637523.png)

![image-20231203163732563](H:/typora%E5%9B%BE%E7%89%87/image-20231203163732563.png)

![image-20231204110517746](H:/typora%E5%9B%BE%E7%89%87/image-20231204110517746.png)

查看为I2C配置的结构体指针，输入deviceId

![image-20231203163859421](H:/typora%E5%9B%BE%E7%89%87/image-20231203163859421.png)

查看deviceId

![image-20231203163943532](H:/typora%E5%9B%BE%E7%89%87/image-20231203163943532.png)

![image-20231203164014033](H:/typora%E5%9B%BE%E7%89%87/image-20231203164014033.png)

![image-20231203164112457](H:/typora%E5%9B%BE%E7%89%87/image-20231203164112457.png)

查看

![image-20231203164215347](H:/typora%E5%9B%BE%E7%89%87/image-20231203164215347.png)

返回一个有符号的32位整型

（iicPs的变量，传进一个指针

上一步中获取的config

结构体成员变量的地址）

![image-20231203164258135](H:/typora%E5%9B%BE%E7%89%87/image-20231203164258135.png)

设置工作速度：setslck

![image-20231203164527846](H:/typora%E5%9B%BE%E7%89%87/image-20231203164527846.png)

![image-20231203164621360](H:/typora%E5%9B%BE%E7%89%87/image-20231203164621360.png)

## 代码

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
//引入iic和parameter的头文件
#include "xiicps.h"
#include "xparameters.h"

//#define 常量名 常量值
#define IIC_DEVICE_ID XPAR_PS7_I2C_0_DEVICE_ID
#define IIC_RATE 100000
//从机地址
#define IIC_SLV_ADDR 0x40

//XIicPs和XIicPs_Config全局的静态变量
static XIicPs IicPs;
static XIicPs_Config * IicPsCfgPtr;
//initial iic
int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg);
//avg filter
double avgfilter(double * srcDataPtr,double inData,int count);

int main()
{
	int status;
    status = initIicPs(&IicPs,IicPsCfgPtr);
    if(status != XST_SUCCESS){
    			return	XST_FAILURE;
    }
    //读命令
    char CmdHum = 0xE5;
    char CmdTemp =0xE3;
    char Hdata[2];//读出2个字节
    char Tdata[2];
    double Tout,Hout;
    double avgdata[4];
    avgdata[0]=0;
    avgdata[1]=0;
    avgdata[2]=0;
    avgdata[3]=0;
    unsigned short tmp =0;
    while(1){
		//read temp value 连续发送 不带中断
    	//0x01：读的字节数
		status = XIicPs_MasterSendPolled(&IicPs,&CmdTemp,0x01,IIC_SLV_ADDR);
		if(status != XST_SUCCESS){
						return	XST_FAILURE;
		}
		//连续接收
		status = XIicPs_MasterRecvPolled(&IicPs,Tdata,0x02,IIC_SLV_ADDR);
		//read hum value
		status = XIicPs_MasterSendPolled(&IicPs,&CmdHum,0x01,IIC_SLV_ADDR);
		if(status != XST_SUCCESS){
						return	XST_FAILURE;
		}
		status = XIicPs_MasterRecvPolled(&IicPs,Hdata,0x02,IIC_SLV_ADDR);
		tmp = (Tdata[0]<<8) | (Tdata[1]&0xfc);
		Tout = (175.72*tmp/65536)-46.85;
		tmp =(Hdata[0]<<8) | (Hdata[1]&0xfe);
		Hout = ((125*tmp)/65536) - 6;
		Tout = avgfilter(avgdata,Tout,0x04);
		printf("Humidity = %.1f; temperature = %.1f \n",Hout,Tout);
		usleep(1000000);
    }
    return 0;
}

int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg){
	int status;//存储返回值信息，标志返回值正确/错误
	//查找配置
	iiccfg = XIicPs_LookupConfig(IIC_DEVICE_ID);
	//初始化
	// -> 访问struct内部成员变量
	status = XIicPs_CfgInitialize(iicps,iiccfg,iiccfg->BaseAddress);
	if(status != XST_SUCCESS){
		return	XST_FAILURE;
	}
	//set iic rate
	status = XIicPs_SetSClk(iicps,IIC_RATE);
	if(status != XST_SUCCESS){
			return	XST_FAILURE;
	}
	return XST_SUCCESS;
}

double avgfilter(double * srcDataPtr,double inData,int count){
	int i;
	double outdata;
	for(i=0;i<count;i++){
		if(i <(count-1)){
			srcDataPtr[i+1]=srcDataPtr[i];
		}
	}
	srcDataPtr[0] =inData;
	outdata = (srcDataPtr[0] + srcDataPtr[1] + srcDataPtr[2] +srcDataPtr[3])/4;
	return outdata;
}

```

```verilog
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
//引入iic和parameter的头文件
#include "xiicps.h"
#include "xparameters.h"

//#define 常量名 常量值
#define IIC_DEVICE_ID XPAR_PS7_I2C_0_DEVICE_ID
#define IIC_RATE 100000
//从机地址
#define IIC_SLV_ADDR 0x40

//XIicPs和XIicPs_Config全局的静态变量
static XIicPs IicPs;
static XIicPs_Config * IicPsCfgPtr;
//initial iic
int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg);

int main()
{
	int status;
	status=initIicPs(&IicPs,IicPsCfgPtr);
		if(status != XST_SUCCESS){
						return	XST_FAILURE;
		}
	    char CmdHum = 0xE5;
	    char CmdTemp =0xE3;
	    char Hdata[2];//读出2个字节
	    char Tdata[2];
	    double Tout,Hout;
	    unsigned short tmp =0;//2字节
	 //temperature
	//s32 XIicPs_MasterSendPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	 while (1){
	status = XIicPs_MasterSendPolled(&IicPs,&CmdTemp,0x01,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_MasterRecvPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	//数组就是指针类型的，不用取地址
	status = XIicPs_MasterRecvPolled(&IicPs,Tdata,0x02,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//先读出来高字节，放到0地址中
	//左移8位变成高八位，低八位为0.低8位就是Tdata[1]&0xFC.
	//将左括号低位补8个0，右括号中的数高位补8个0，按位或
	tmp=(Tdata[0]<<8) | (Tdata[1]&0xFC);
	Tout = (175.72*tmp/65536)-46.85;
	//Humidity
	//s32 XIicPs_MasterSendPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	status = XIicPs_MasterSendPolled(&IicPs,&CmdHum,0x01,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_MasterRecvPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	//数组就是指针类型的，不用取地址
	status = XIicPs_MasterRecvPolled(&IicPs,Hdata,0x02,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	tmp =(Hdata[0]<<8) | (Hdata[1]&0xFC);
	Hout = ((125*tmp)/65536) - 6;
	printf("Temperature = %.1f ; Humidity = %.1f \n",Tout,Hout);
	usleep(1000000);
	}
    return 0;
}

int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg){
	int status;
	//return (XIicPs_Config *)CfgPtr;
	iiccfg=XIicPs_LookupConfig(IIC_DEVICE_ID);
	//
	//s32 XIicPs_CfgInitialize(XIicPs *InstancePtr, XIicPs_Config * ConfigPtr,u32 EffectiveAddr);
	status=XIicPs_CfgInitialize(iicps,iiccfg,iiccfg->BaseAddress);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_SetSClk(XIicPs *InstancePtr, u32 FsclHz);
	status=XIicPs_SetSClk(iicps,IIC_RATE);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	return XST_SUCCESS;
}


```



运行

编译成功

![image-20231204093706730](H:/typora%E5%9B%BE%E7%89%87/image-20231204093706730.png)

板卡上电

调试

![image-20231204093800338](H:/typora%E5%9B%BE%E7%89%87/image-20231204093800338.png)

双击

![image-20231204093818912](H:/typora%E5%9B%BE%E7%89%87/image-20231204093818912.png)

![image-20231204095034840](H:/typora%E5%9B%BE%E7%89%87/image-20231204095034840.png)

## 练习：

# **第四讲、驱动** **GPIO** **使用** **GPIO** **中断模式**

## 驱动** **GPIO**

### 原理

不带PS的就是FPGA这一侧

![image-20231205092750591](H:/typora%E5%9B%BE%E7%89%87/image-20231205092750591.png)

![image-20231205092825813](H:/typora%E5%9B%BE%E7%89%87/image-20231205092825813.png)

### 实验

创建工程

![image-20231205093145147](H:/typora%E5%9B%BE%E7%89%87/image-20231205093145147.png)

![image-20231205093206438](H:/typora%E5%9B%BE%E7%89%87/image-20231205093206438.png)

![image-20231205094132992](H:/typora%E5%9B%BE%E7%89%87/image-20231205094132992.png)

![image-20231205094154279](H:/typora%E5%9B%BE%E7%89%87/image-20231205094154279.png)

![image-20231205094224899](H:/typora%E5%9B%BE%E7%89%87/image-20231205094224899.png)

![image-20231205094306851](H:/typora%E5%9B%BE%E7%89%87/image-20231205094306851.png)

![image-20231205094341020](H:/typora%E5%9B%BE%E7%89%87/image-20231205094341020.png)

![image-20231205094359133](H:/typora%E5%9B%BE%E7%89%87/image-20231205094359133.png)

其中两个作为LED灯的驱动，另外一个作为按键的驱动

![image-20231205094441349](H:/typora%E5%9B%BE%E7%89%87/image-20231205094441349.png)

按照之前的配置DDR。

![image-20231205094546025](H:/typora%E5%9B%BE%E7%89%87/image-20231205094546025.png)

点击后左侧修改名字

![image-20231205094628315](H:/typora%E5%9B%BE%E7%89%87/image-20231205094628315.png)

![image-20231205094652217](H:/typora%E5%9B%BE%E7%89%87/image-20231205094652217.png)

到了fpga，需要绑定引脚

![image-20231205094938444](H:/typora%E5%9B%BE%E7%89%87/image-20231205094938444.png)

创建一个xdc（Xilinx design constraint）文件。（ise中成为ucf文件）（vivado中成为xdc文件）

![image-20231205095129333](H:/typora%E5%9B%BE%E7%89%87/image-20231205095129333.png)

![image-20231205095139363](H:/typora%E5%9B%BE%E7%89%87/image-20231205095139363.png)

![image-20231205095159903](H:/typora%E5%9B%BE%E7%89%87/image-20231205095159903.png)

语法：

![image-20231205095316724](H:/typora%E5%9B%BE%E7%89%87/image-20231205095316724.png)

![image-20231205095349806](H:/typora%E5%9B%BE%E7%89%87/image-20231205095349806.png)

指定pin的位置![image-20231205095402086](H:/typora%E5%9B%BE%E7%89%87/image-20231205095402086.png)

 ![image-20231205095504061](H:/typora%E5%9B%BE%E7%89%87/image-20231205095504061.png)

另一个用顶层接口信号

![image-20231205095525794](H:/typora%E5%9B%BE%E7%89%87/image-20231205095525794.png)

LED0\LED1\PUSH

![image-20231205095710814](H:/typora%E5%9B%BE%E7%89%87/image-20231205095710814.png)

![image-20231205095729986](H:/typora%E5%9B%BE%E7%89%87/image-20231205095729986.png)

查看这些引脚的芯片名字，bank34、bank35，都是接3.3v

![image-20231205095840539](H:/typora%E5%9B%BE%E7%89%87/image-20231205095840539.png)

![image-20231205100024478](H:/typora%E5%9B%BE%E7%89%87/image-20231205100024478.png)

![image-20231205100040177](H:/typora%E5%9B%BE%E7%89%87/image-20231205100040177.png)

*就是通配符，里面所有的都是 LVCMOS33约束的。

生成bit文件

![image-20231205100411494](H:/typora%E5%9B%BE%E7%89%87/image-20231205100411494.png)

![image-20231205100451512](H:/typora%E5%9B%BE%E7%89%87/image-20231205100451512.png)

launch  SDK

创建新工程

![image-20231205100553034](H:/typora%E5%9B%BE%E7%89%87/image-20231205100553034.png)、、

### 代码

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xgpiops.h"
#include "xparameters.h"

#define GPIO_DEV_ID XPAR_PS7_DEV_CFG_0_DEVICE_ID
#define LED0 54
#define LED1 55
#define SW0 56
//生成全局的
static XGpioPs gpiops;
static XGpioPs_Config *gpio_conf;

int initgpio();

int main()
{
	initgpio();
	u32 led=0;
	while(1){
		//* Write data to the specified pin.
		//(XGpioPs *InstancePtr, u32 Pin, u32 Data);
		XGpioPs_WritePin(&gpiops,LED0,led);
		usleep(500000);
		led=~led;
	}
    return 0;
}

int initgpio(){
	int status;
	gpio_conf=XGpioPs_LookupConfig(GPIO_DEV_ID);
	status=XGpioPs_CfgInitialize(&gpiops,gpio_conf,gpio_conf->BaseAddr);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	XGpioPs_SetDirectionPin(&gpiops,LED0,0x01);
	XGpioPs_SetDirectionPin(&gpiops,LED1,0x01);
	XGpioPs_SetDirectionPin(&gpiops,SW0,0x00);//input
	//Set the Output Enable of the specified pin.
	XGpioPs_SetOutputEnablePin(&gpiops,LED0,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,LED1,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,SW0,0x00);
}

```



### 添加温度功能

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xgpiops.h"
#include "xparameters.h"
#include "xiicps.h"
#include "xparameters.h"

#define GPIO_DEV_ID XPAR_PS7_DEV_CFG_0_DEVICE_ID
#define LED0 54
#define LED1 55
#define SW0 56
#define IIC_DEVICE_ID XPAR_PS7_I2C_0_DEVICE_ID
#define IIC_RATE 100000
#define IIC_SLV_ADDR 0x40
//生成全局的
static XGpioPs gpiops;
static XGpioPs_Config *gpio_conf;
static XIicPs IicPs;
static XIicPs_Config * IicPsCfgPtr;
int initgpio();
int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg);
int main()
{
	initgpio();
	int status;
		status=initIicPs(&IicPs,IicPsCfgPtr);
			if(status != XST_SUCCESS){
							return	XST_FAILURE;
			}
	u32 led=0;
    char CmdHum = 0xE5;
    char CmdTemp =0xE3;
    char Hdata[2];//读出2个字节
    char Tdata[2];
    double Tout,Hout;
    unsigned short tmp =0;//2字节
    int flag=0;
	while(1){
		status = XIicPs_MasterSendPolled(&IicPs,&CmdTemp,0x01,IIC_SLV_ADDR);
			if(status != XST_SUCCESS){
							return	XST_FAILURE;
			}
			//s32 XIicPs_MasterRecvPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
			//数组就是指针类型的，不用取地址
			status = XIicPs_MasterRecvPolled(&IicPs,Tdata,0x02,IIC_SLV_ADDR);
			if(status != XST_SUCCESS){
							return	XST_FAILURE;
			}
			//先读出来高字节，放到0地址中
			//左移8位变成高八位，低八位为0.低8位就是Tdata[1]&0xFC.
			//将左括号低位补8个0，右括号中的数高位补8个0，按位或
			tmp=(Tdata[0]<<8) | (Tdata[1]&0xFC);
			Tout = (175.72*tmp/65536)-46.85;
			//Humidity
			//s32 XIicPs_MasterSendPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
			status = XIicPs_MasterSendPolled(&IicPs,&CmdHum,0x01,IIC_SLV_ADDR);
			if(status != XST_SUCCESS){
							return	XST_FAILURE;
			}
			//s32 XIicPs_MasterRecvPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
			//数组就是指针类型的，不用取地址
			status = XIicPs_MasterRecvPolled(&IicPs,Hdata,0x02,IIC_SLV_ADDR);
			if(status != XST_SUCCESS){
							return	XST_FAILURE;
			}
			tmp =(Hdata[0]<<8) | (Hdata[1]&0xFC);
			Hout = ((125*tmp)/65536) - 6;
			printf("Temperature = %.1f ; Humidity = %.1f \n",Tout,Hout);

			if (Tout>27){
				//* Write data to the specified pin.
				//(XGpioPs *InstancePtr, u32 Pin, u32 Data);
				XGpioPs_WritePin(&gpiops,LED0,led);

				led=~led;
			}
			else {
				led=0;
				XGpioPs_WritePin(&gpiops,LED0,led);
			}

			usleep(500000);
	}
    return 0;
}

int initgpio(){
	int status;
	gpio_conf=XGpioPs_LookupConfig(GPIO_DEV_ID);
	status=XGpioPs_CfgInitialize(&gpiops,gpio_conf,gpio_conf->BaseAddr);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	XGpioPs_SetDirectionPin(&gpiops,LED0,0x01);
	XGpioPs_SetDirectionPin(&gpiops,LED1,0x01);
	XGpioPs_SetDirectionPin(&gpiops,SW0,0x00);//input
	//Set the Output Enable of the specified pin.
	XGpioPs_SetOutputEnablePin(&gpiops,LED0,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,LED1,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,SW0,0x00);
}
int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg){
	int status;
	//return (XIicPs_Config *)CfgPtr;
	iiccfg=XIicPs_LookupConfig(IIC_DEVICE_ID);
	//
	//s32 XIicPs_CfgInitialize(XIicPs *InstancePtr, XIicPs_Config * ConfigPtr,u32 EffectiveAddr);
	status=XIicPs_CfgInitialize(iicps,iiccfg,iiccfg->BaseAddress);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_SetSClk(XIicPs *InstancePtr, u32 FsclHz);
	status=XIicPs_SetSClk(iicps,IIC_RATE);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	return XST_SUCCESS;
}

```

### 呼吸灯

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xgpiops.h"
#include "xparameters.h"

#define GPIO_DEV_ID XPAR_PS7_DEV_CFG_0_DEVICE_ID
#define LED0 54
#define LED1 55
#define SW0 56
//生成全局的
static XGpioPs gpiops;
static XGpioPs_Config *gpio_conf;

int initgpio();

int main()
{
	initgpio();
	u32 led=1;
	int i,j;
	while(1){
		//* Write data to the specified pin.
		//(XGpioPs *InstancePtr, u32 Pin, u32 Data);
		//XGpioPs_WritePin(&gpiops,LED0,led);
		for (i=0;i<999;i++){
			for (j=0;j<999;j++){
				usleep(1);
				if (j<i){
					XGpioPs_WritePin(&gpiops,LED0,led);
				}
				else{
					XGpioPs_WritePin(&gpiops,LED0,~led);
				}
			}
		}
		led=~led;
	}
    return 0;
}

int initgpio(){
	int status;
	gpio_conf=XGpioPs_LookupConfig(GPIO_DEV_ID);
	status=XGpioPs_CfgInitialize(&gpiops,gpio_conf,gpio_conf->BaseAddr);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	XGpioPs_SetDirectionPin(&gpiops,LED0,0x01);
	XGpioPs_SetDirectionPin(&gpiops,LED1,0x01);
	XGpioPs_SetDirectionPin(&gpiops,SW0,0x00);//input
	//Set the Output Enable of the specified pin.
	XGpioPs_SetOutputEnablePin(&gpiops,LED0,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,LED1,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,SW0,0x00);
}


```

回顾呼吸灯原理、三目运算符

```verilog
 assign a=(b>6)?1'b1:1'b0;
//当 b 大于 6 时将顿号前面的值赋值给 a，不然将顿号后面的值赋值给 a。
```

![image-20231205162149964](H:/typora%E5%9B%BE%E7%89%87/image-20231205162149964.png)

原理：

这个是2s亮，2s灭。

在亮的两秒中，将两秒分为1000份，每份为```pwm_cyc_cnt```计数。再将```pwm_cyc_cnt```分为1000份，每份为```clk50Mcnt_1000```，记录高低电平数目。

其实```pwm_cyc_cnt```的另一个作用就是当作```clk50Mcnt_1000```的判断条件。

```verilog
assign led=(pwm_flag==1'b0)?((clk50Mcnt_1000<pwn_cyc_cnt)?1'b0:1'b1):((clk50Mcnt_1000<pwn_cyc_cnt)?1'b1:1'b0);
```

当```pwm_cyc_cnt=0```，```clk50Mcnt_1000=0```，led=0；

当```pwm_cyc_cnt=1```，```clk50Mcnt_1000=0```，led=1；

当```pwm_cyc_cnt=2```，```clk50Mcnt_1000=0,1```，led=1；

当```pwm_cyc_cnt=3```，```clk50Mcnt_1000=0,1,2```，led=1；

当```pwm_cyc_cnt=4```，```clk50Mcnt_1000=0,1,2,3```，led=1；

......

当```pwm_cyc_cnt=999```，```clk50Mcnt_1000=0,1,2,3......998```，led=1；

接着将led取反，重新上述操作为灭的周期。

## **GPIO 中断模式的使用和原理** 

GPIO 中断系统初始化流程：

第一步:初始化 cpu 的异常处理功能

Xil_ExceptionInit();

第二步：初始化中断控制器

XScuGic_LookupConfig()

XScuGic_CfgInitialize()

第三步：向 CPU 注册异常处理回调函数；

Xil_ExceptionRegisterHandler()

第四步：将中断控制器中的对应中断 ID 的中断与中断控制器相连接

XScuGic_Connect()

第五步：设置 GPIO 的中断类型，比如高电平中断、低电平中断、上升沿中断、

下降沿中断等。

XGpioPs_SetIntrType()

第六步：设置 GPIO 中断回调函数，这里设置的回调函数是用于用户使用的。

XGpioPs_SetCallbackHandler()

第七步：使能 GPIO 的对应 PIN 的中断

XGpioPs_IntrEnable()

第八步：使能中断控制器

XScuGic_Enable()

第九步：使能异常处理功能

Xil_ExceptionEnableMask()

### 实验步骤

创建sdk project

![image-20231205192257742](H:/typora%E5%9B%BE%E7%89%87/image-20231205192257742.png)



查找中断头文件

![image-20231205192901588](H:/typora%E5%9B%BE%E7%89%87/image-20231205192901588.png)

选择普通中断ID，不是快速中断，gic的实例化的中断地址。

接收到回调函数查看是不是中断，再查看是不是gpio的

![image-20231205203551942](H:/typora%E5%9B%BE%E7%89%87/image-20231205203551942.png)



gicps、中断id：gpio的中断id![image-20231205194330914](H:/typora%E5%9B%BE%E7%89%87/image-20231205194330914.png)，中断处理函数：

![image-20231205200734624](H:/typora%E5%9B%BE%E7%89%87/image-20231205200734624.png)

中断类型：电平中断/边沿中断

bankID

![image-20231205194815815](H:/typora%E5%9B%BE%E7%89%87/image-20231205194815815.png)

![image-20231205194943967](H:/typora%E5%9B%BE%E7%89%87/image-20231205194943967.png)

按下之后由高变低，下降沿有效，0x00

 ![image-20231205195342964](H:/typora%E5%9B%BE%E7%89%87/image-20231205195342964.png)

单沿触发0x00

回调函数：用户用的。按完按键，就可以进到这个回调函数中，在这里做相应处理。

回调函数不会被其它地方调用，所以用void

![image-20231205200252765](H:/typora%E5%9B%BE%E7%89%87/image-20231205200252765.png)

![image-20231205200953026](H:/typora%E5%9B%BE%E7%89%87/image-20231205200953026.png)

![image-20231205203657044](H:/typora%E5%9B%BE%E7%89%87/image-20231205203657044.png)

通过这个中断回调函数访问gpio

读取当前按键状态，按键按下，是0

![image-20231205203203381](H:/typora%E5%9B%BE%E7%89%87/image-20231205203203381.png)





对bank的哪个管脚使用中断

![image-20231205201430111](H:/typora%E5%9B%BE%E7%89%87/image-20231205201430111.png)

对应着32位中的0，1，2的第2个比特，把第二个比特给成1

![image-20231205201702629](H:/typora%E5%9B%BE%E7%89%87/image-20231205201702629.png)

把1左移两位，ENIOGPIOTN=1，SW0=56，![image-20231205201806932](H:/typora%E5%9B%BE%E7%89%87/image-20231205201806932.png)

使能异常处理，把这个给打开

![image-20231205202225281](H:/typora%E5%9B%BE%E7%89%87/image-20231205202225281.png)

加一个while防止程序挂起，中断才可以相应

![image-20231205204428323](H:/typora%E5%9B%BE%E7%89%87/image-20231205204428323.png)

因为加了中断，停了一下，读的时候已经变成1了

![image-20231205204647410](H:/typora%E5%9B%BE%E7%89%87/image-20231205204647410.png)

到这里直接打印就好了

```c
//读取按键状态，如果按键按下=0，则把led点亮=1
void intrHandler(void *CallBackRef,u32 Bank,u32 status){
	XGpioPs *GpioPtr;
	GpioPtr=(XGpioPs *)CallBackRef;//?
	u32 readSW;
	readSW=XGpioPs_ReadPin(GpioPtr,SW0);
	printf("readSW = %d \n",(int)readSW);
	if (readSW==0){
		XGpioPs_WritePin(GpioPtr,LED1,0x01);
	}
}
```

![image-20231206153849424](H:/typora%E5%9B%BE%E7%89%87/image-20231206153849424.png)

### 中断去抖

100ms就稳定了

readSW=1：按键抬起。0是接地。1是接高电平。

![image-20231205220052322](H:/typora%E5%9B%BE%E7%89%87/image-20231205220052322.png)

当按键按下后抬起，稳定后，打印出的是1.



进到函数里面需要将中断进行清除。在这个过程中（抖动）停掉中断，就算再来中断也不会触发。

![image-20231205220531916](H:/typora%E5%9B%BE%E7%89%87/image-20231205220531916.png)

抖动结束后恢复中断检测

![image-20231205220621395](H:/typora%E5%9B%BE%E7%89%87/image-20231205220621395.png)

```c
//读取按键状态，如果按键按下=0，则把led点亮=1
void intrHandler(void *CallBackRef,u32 Bank,u32 status){
	XGpioPs *GpioPtr;
	GpioPtr=(XGpioPs *)CallBackRef;//?
	XGpioPs_IntrClearPin(GpioPtr,SW0);
	XGpioPs_IntrDisablePin(GpioPtr,SW0);
	u32 readSW;
	int cnt=0;
	while (cnt<100){
		readSW=XGpioPs_ReadPin(GpioPtr,SW0);
		if (readSW==1){ //抬起后计数到100，100ms后我们记为达到稳定状态
			cnt++;
		}
		else {
			cnt=0;
		}
		usleep(1000);
	}

	printf("readSW = %d \n",(int)readSW);
	if (readSW==0){
		XGpioPs_WritePin(GpioPtr,LED1,0x01);
	}
}
```



###  读到两次按键按下的原因：

![image-20231205221302439](H:/typora%E5%9B%BE%E7%89%87/image-20231205221302439-1701785610080-1.png)

进入两次bank的原因：



开始的时候。按下按键

![image-20231205220743861](H:/typora%E5%9B%BE%E7%89%87/image-20231205220743861.png)

再运行

![image-20231205220917108](H:/typora%E5%9B%BE%E7%89%87/image-20231205220917108.png)





EMIO有两个bank

![image-20231205213329733](H:/typora%E5%9B%BE%E7%89%87/image-20231205213329733.png)

这64个管脚任意一个产生中断的时候，都会进入这个中断回调函数两次。因为这个回调函数共用于bank2和bank3。bank3其实没有产生中断，中断ID只有一个，只要在这64个管脚中产生中断，就都会分别给bank0和bank1一次中断。所以需要判断是不是当前引脚中的中断。

通过下列函数查看管脚是否产生中断

![image-20231205213849751](H:/typora%E5%9B%BE%E7%89%87/image-20231205213849751.png)

![image-20231205214016531](H:/typora%E5%9B%BE%E7%89%87/image-20231205214016531.png)

### 问题：

![image-20231205221212904](H:/typora%E5%9B%BE%E7%89%87/image-20231205221212904.png)

#### 问题1：按键由何控制

读取管脚的值，按键不按下的时候不也是高电平吗，readSW=1吗？不会直接往下运行吗？



哦哦，那使用第七步的XGpioPs_IntrEnable()，来判断是否按下了按键。

第六步的回调函数和回调函数中的去抖   和第五补的中断类型只是对它进行了设置，其实上电之后才进行的第七步的使能，



在中断系统的初始化流程中，通过设置GPIO的中断类型和回调函数来判断是否按下了中断按键。

具体来说，在第五步中使用了函数XGpioPs_SetIntrType()来设置GPIO的中断类型。你可以将中断类型设置为上升沿（rising edge）或下降沿（falling edge），以便在按下或释放中断按键时触发中断。

在第六步中使用了函数XGpioPs_SetCallbackHandler()来设置GPIO的中断回调函数。中断回调函数是一个用户定义的函数，当按下中断按键时会被调用。你可以在这个回调函数中编写你想要执行的操作，如发送信号、执行特定功能等。

然后，在第七步中使用了函数XGpioPs_IntrEnable()来使能GPIO对应PIN的中断。开启中断之后，当按下中断按键时，中断控制器会检测到中断信号，并且会调用之前设置的中断回调函数。

通过以上步骤，你可以在中断回调函数中进行判断，判断是否按下了中断按键，从而执行相应的操作。



![1701854663770](H:/typora%E5%9B%BE%E7%89%87/1701854663770.jpg)

#### 问题2：使能管脚如何设置

![image-20231206194639404](H:/typora%E5%9B%BE%E7%89%87/image-20231206194639404.png)

如何知道mask是100的，是因为设置了三个管脚，LED0，LED1，SW0，SW0排在第三位所以才设置为100的吗？

这三个是不是在bank2中的EMIOGPIOI[31:0]的低三位

对bank的哪个管脚使用中断

![image-20231205201430111](H:/typora%E5%9B%BE%E7%89%87/image-20231205201430111.png)

对应着32位中的0，1，2的第2个比特，把第二个比特给成1

![image-20231205201702629](H:/typora%E5%9B%BE%E7%89%87/image-20231205201702629.png)

把1左移两位，ENIOGPIOTN=1，SW0=56，![image-20231205201806932](H:/typora%E5%9B%BE%E7%89%87/image-20231205201806932.png)



#### 问题3：去抖函数中的bank

在去抖的函数里解决进入两次bank的原因的时候，bank的值是0和1，是如何得到的，是SW0给的吗，bank2的值是SW0按下的0，另一个是抬起的状态1.

![image-20231206195006464](H:/typora%E5%9B%BE%E7%89%87/image-20231206195006464.png)

这里就是zynq的gpio有0-1 bank。设计这个芯片就是这样划分的。

#### 问题4：void和int声明函数区别

void和int表示函数的返回类型，它们有以下不同之处：

- void：当函数没有返回值时，可以使用void作为返回类型。这意味着函数不会返回任何值给调用者。void函数通常用于执行某些操作而不需要返回结果的情况。

示例：

```c
void greet() {
    printf("Hello, World!\n");
}
```

- int：当函数需要返回一个整数值给调用者时，可以使用int作为返回类型。这意味着函数执行结束后会返回一个整数值。调用者可以将该返回值存储在变量中或进行其他操作。

示例：

```c
int add(int a, int b) {
    return a + b;
}
```

需要注意的是，函数的返回类型必须与函数实际返回的值类型一致。如果函数声明为void类型，则不应该在函数体内使用return语句返回值；如果函数声明为int类型，则必须使用return语句返回一个整数值。

#### 问题5：中断处理器

中断控制器是计算机系统中的一种重要硬件，它的主要作用是对外部设备产生的中断信号进行处理和管理，将中断信号传递给CPU，并根据中断优先级来决定CPU处理哪一个中断。中断控制器在计算机系统中扮演着重要的角色，它能够提高系统的可靠性、实时性和稳定性。

在计算机系统中，外部设备（如磁盘、键盘、鼠标等）可能会向CPU发送中断请求，当CPU接收到中断请求后，就会停止当前的工作进程，转而处理中断程序。中断控制器就是负责管理和协调这些中断请求的硬件设备，它可以检测到外部设备发出的中断请求信号，同时能够按照事先设定好的优先级规则，将中断请求顺序地传递给CPU，从而实现对中断的控制和管理。

总而言之，中断控制器的作用是协调管理外部设备发送的中断信号，实现中断的控制和管理，提高系统的可靠性、实时性和稳定性。

### 代码

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xgpiops.h"
#include "xparameters.h"
#include "xscugic.h"

#define GPIO_DEV_ID XPAR_PS7_GPIO_0_DEVICE_ID
#define GIC_DEV_ID XPAR_PS7_SCUGIC_0_DEVICE_ID
#define LED0 54
#define LED1 55
#define SW0 56
#define GPIO_INTR_ID 52
#define SW_BANK_ID 2
//生成全局的
static XGpioPs gpiops;
static XGpioPs_Config *gpio_conf;

static XScuGic Gicps;
static XScuGic_Config *GicPsPtr;

int initGpio();
int setupInterrupt();
void intrHandler(void *CallBackRef,u32 Bank,u32 status);
int main()
{
	initGpio();
	setupInterrupt();
	while(1){
	}
    return 0;
}

int initGpio(){
	int status;
	gpio_conf=XGpioPs_LookupConfig(GPIO_DEV_ID);
	status=XGpioPs_CfgInitialize(&gpiops,gpio_conf,gpio_conf->BaseAddr);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	XGpioPs_SetDirectionPin(&gpiops,LED0,0x01);
	XGpioPs_SetDirectionPin(&gpiops,LED1,0x01);
	XGpioPs_SetDirectionPin(&gpiops,SW0,0x00);//input
	//Set the Output Enable of the specified pin.
	XGpioPs_SetOutputEnablePin(&gpiops,LED0,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,LED1,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,SW0,0x00);
}
//中断函数
int setupInterrupt(){
	int status;
	Xil_ExceptionInit();
	GicPsPtr=XScuGic_LookupConfig(GIC_DEV_ID);
	status=XScuGic_CfgInitialize(&Gicps,GicPsPtr,GicPsPtr->CpuBaseAddress);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//异常处理回调函数，选择普通中断，gpio中断
	//(u32 Exception_id,Xil_ExceptionHandler Handler,void *Data)
	//?
	/*XScuGic_InterruptHandler
	 该函数是驱动程序的主要中断处理程序。一定是连接到中断源，以便当中断时调用它中断控制器处于活动状态。
	 它将解决哪些中断激活并启用并调用适当的中断处理程序。它用中断类型信息以确定何时确认中断。首先处理最高优先级的中断。
	 */
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,&Gicps);
	//将中断控制器中的对应中断 ID 的中断与中断控制器相连接
	//XScuGic_Connect 在中断源的 Int_Id 和识别中断时要运行的关联处理程序之间建立连接。
	//在此调用中作为 Callbackref 提供的参数在调用处理程序时用作处理程序的参数。
	//XScuGic *InstancePtr, u32 Int_Id,Xil_InterruptHandler Handler, void *CallBackRef
	//CallBackRef	is the callback reference, usually the instance pointer of the connecting driver.
	//XGpioPs_IntrHandler 该函数是GPIO中断的中断处理程序。它检查所有Bank的中断状态寄存器，以确定触发中断的实际Bank。
	//然后调用函数XGpioPs_SetBankHandler()设置的上层回调处理程序。中断时调用回调
	//?
	status=XScuGic_Connect(&Gicps,GPIO_INTR_ID,(Xil_InterruptHandler)XGpioPs_IntrHandler,&gpiops);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//XGpioPs *InstancePtr, u8 Bank, u32 IntrType,u32 IntrPolarity, u32 IntrOnAny
	//bank2，边沿触发、按键下降沿触发，单个边缘触发
	XGpioPs_SetIntrType(&gpiops,SW_BANK_ID,0xffffffff,0x00,0x00);
	//XGpioPs *InstancePtr, void *CallBackRef,XGpioPs_Handler FuncPointer
	//设置 GPIO 中断回调函数，这里设置的回调函数是用于用户使用的。
	XGpioPs_SetCallbackHandler(&gpiops,(void *)&gpiops,intrHandler);
	//XGpioPs *InstancePtr, u8 Bank, u32 Mask
	XGpioPs_IntrEnable(&gpiops,SW_BANK_ID,1<<(SW0-54));
	//* 启用作为参数 Int_Id 提供的中断源。任何待处理的
	//指定 Int_Id 的中断条件将在该函数执行后发生发生。
	XScuGic_Enable(&Gicps,GPIO_INTR_ID);
	//
	Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);
	return	XST_SUCCESS;
}

//读取按键状态，如果按键按下=0，则把led点亮=1
void intrHandler(void *CallBackRef,u32 Bank,u32 status){
	XGpioPs *GpioPtr;
	GpioPtr=(XGpioPs *)CallBackRef;//?
	int intrstatus;
	intrstatus=XGpioPs_IntrGetStatusPin(GpioPtr,SW0);
	if (intrstatus==1){
		XGpioPs_IntrClearPin(GpioPtr,SW0);
		XGpioPs_IntrDisablePin(GpioPtr,SW0);
		int cnt=0;
		u32 readSW=0;
		while (cnt<100){
			readSW=XGpioPs_ReadPin(GpioPtr,SW0);
			if (readSW==1){ //抬起后计数到100，100ms后我们记为达到稳定状态
				cnt++;
			}
			else {
				cnt=0;
			}
			usleep(1000);
		}
		printf("readSW = %d \n",(int)readSW);
		if (readSW==0){
			XGpioPs_WritePin(GpioPtr,LED1,0x01);
		}
		XGpioPs_IntrEnablePin(GpioPtr,SW0);//恢复使能
	}
}

```

## 练习：

通过按键中断去读取 IIC 的温度和湿度值，并且通过串口打印给上位机。

思路：温湿度需要放在按下按键的那里。将温湿度的设置放置到一个readDev(double *DataBuf)的函数中，通过这个函数得到温湿度的值，放到dataBuf[2]中，然后按下按键打印出来

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xgpiops.h"
#include "xparameters.h"
#include "xscugic.h"
//温湿度
#include "xiicps.h"
#include "xparameters.h"

#define GPIO_DEV_ID XPAR_PS7_GPIO_0_DEVICE_ID
#define GIC_DEV_ID XPAR_PS7_SCUGIC_0_DEVICE_ID
#define LED0 54
#define LED1 55
#define SW0 56
#define GPIO_INTR_ID 52
#define SW_BANK_ID 2
#define IIC_DEVICE_ID XPAR_PS7_I2C_0_DEVICE_ID
#define IIC_RATE 100000
//从机地址
#define IIC_SLV_ADDR 0x40
//生成全局的
static XGpioPs gpiops;
static XGpioPs_Config *gpio_conf;

static XScuGic Gicps;
static XScuGic_Config *GicPsPtr;

static XIicPs IicPs;
static XIicPs_Config * IicPsCfgPtr;

int initGpio();
int setupInterrupt();
int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg);

void intrHandler(void *CallBackRef,u32 Bank,u32 status);
void readDev(double *DataBuf);

int main()
{
	initIicPs(&IicPs,IicPsCfgPtr);
	initGpio();
	setupInterrupt();
	while (1){

	}
    return 0;
}
//初始化灯
int initGpio(){
	int status;
	gpio_conf=XGpioPs_LookupConfig(GPIO_DEV_ID);
	status=XGpioPs_CfgInitialize(&gpiops,gpio_conf,gpio_conf->BaseAddr);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	XGpioPs_SetDirectionPin(&gpiops,LED0,0x01);
	XGpioPs_SetDirectionPin(&gpiops,LED1,0x01);
	XGpioPs_SetDirectionPin(&gpiops,SW0,0x00);//input
	//Set the Output Enable of the specified pin.
	XGpioPs_SetOutputEnablePin(&gpiops,LED0,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,LED1,0x01);
	XGpioPs_SetOutputEnablePin(&gpiops,SW0,0x00);
}
//中断函数
int setupInterrupt(){
	int status;
	Xil_ExceptionInit();
	GicPsPtr=XScuGic_LookupConfig(GIC_DEV_ID);
	status=XScuGic_CfgInitialize(&Gicps,GicPsPtr,GicPsPtr->CpuBaseAddress);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//异常处理回调函数，选择普通中断，gpio中断
	//(u32 Exception_id,Xil_ExceptionHandler Handler,void *Data)
	//?
	/*XScuGic_InterruptHandler
	 该函数是驱动程序的主要中断处理程序。一定是连接到中断源，以便当中断时调用它中断控制器处于活动状态。
	 它将解决哪些中断激活并启用并调用适当的中断处理程序。它用中断类型信息以确定何时确认中断。首先处理最高优先级的中断。
	 */
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,&Gicps);
	//将中断控制器中的对应中断 ID 的中断与中断控制器相连接
	//XScuGic_Connect 在中断源的 Int_Id 和识别中断时要运行的关联处理程序之间建立连接。
	//在此调用中作为 Callbackref 提供的参数在调用处理程序时用作处理程序的参数。
	//XScuGic *InstancePtr, u32 Int_Id,Xil_InterruptHandler Handler, void *CallBackRef
	//CallBackRef	is the callback reference, usually the instance pointer of the connecting driver.
	//XGpioPs_IntrHandler 该函数是GPIO中断的中断处理程序。它检查所有Bank的中断状态寄存器，以确定触发中断的实际Bank。
	//然后调用函数XGpioPs_SetBankHandler()设置的上层回调处理程序。中断时调用回调
	//?
	status=XScuGic_Connect(&Gicps,GPIO_INTR_ID,(Xil_InterruptHandler)XGpioPs_IntrHandler,&gpiops);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//XGpioPs *InstancePtr, u8 Bank, u32 IntrType,u32 IntrPolarity, u32 IntrOnAny
	//bank2，边沿触发、按键下降沿触发，单个边缘触发
	XGpioPs_SetIntrType(&gpiops,SW_BANK_ID,0xffffffff,0x00,0x00);
	//XGpioPs *InstancePtr, void *CallBackRef,XGpioPs_Handler FuncPointer
	//设置 GPIO 中断回调函数，这里设置的回调函数是用于用户使用的。
	XGpioPs_SetCallbackHandler(&gpiops,(void *)&gpiops,intrHandler);
	//XGpioPs *InstancePtr, u8 Bank, u32 Mask
	XGpioPs_IntrEnable(&gpiops,SW_BANK_ID,1<<(SW0-54));
	//* 启用作为参数 Int_Id 提供的中断源。任何待处理的
	//指定 Int_Id 的中断条件将在该函数执行后发生发生。
	XScuGic_Enable(&Gicps,GPIO_INTR_ID);
	//
	Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);
	return	XST_SUCCESS;
}
//读取按键状态，如果按键按下=0，则把led点亮=1
void intrHandler(void *CallBackRef,u32 Bank,u32 status){
	XGpioPs *GpioPtr;
	GpioPtr=(XGpioPs *)CallBackRef;//?
	int intrstatus;
	double DataBuf[2];
	intrstatus=XGpioPs_IntrGetStatusPin(GpioPtr,SW0);
	if (intrstatus==1){
		XGpioPs_IntrClearPin(GpioPtr,SW0);
		XGpioPs_IntrDisablePin(GpioPtr,SW0);
		int cnt=0;
		u32 readSW=0;
		while (cnt<100){
			readSW=XGpioPs_ReadPin(GpioPtr,SW0);
			if (readSW==1){ //抬起后计数到100，100ms后我们记为达到稳定状态
				cnt++;
			}
			else {
				cnt=0;
			}
			usleep(1000);
		}
		printf("readSW = %d \n",(int)readSW);//readSW=1;
		readDev(DataBuf);//读取温度
		printf("Temperature = %.1f ; Humidity = %.1f \n",DataBuf[0],DataBuf[1]);
		if (readSW==0){
			XGpioPs_WritePin(GpioPtr,LED1,0x01);
		}
		XGpioPs_IntrEnablePin(GpioPtr,SW0);//恢复使能
	}
}
//温湿度初始化
int initIicPs(XIicPs *iicps , XIicPs_Config * iiccfg){
	int status;
	//return (XIicPs_Config *)CfgPtr;
	iiccfg=XIicPs_LookupConfig(IIC_DEVICE_ID);
	//
	//s32 XIicPs_CfgInitialize(XIicPs *InstancePtr, XIicPs_Config * ConfigPtr,u32 EffectiveAddr);
	status=XIicPs_CfgInitialize(iicps,iiccfg,iiccfg->BaseAddress);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_SetSClk(XIicPs *InstancePtr, u32 FsclHz);
	status=XIicPs_SetSClk(iicps,IIC_RATE);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	return XST_SUCCESS;
}
//
void readDev(double *DataBuf){
	int status;
	status=initIicPs(&IicPs,IicPsCfgPtr);
		if(status != XST_SUCCESS){
						return	XST_FAILURE;
		}
	    char CmdHum = 0xE5;
	    char CmdTemp =0xE3;
	    char Hdata[2];//读出2个字节
	    char Tdata[2];
	    double Tout,Hout;
	    unsigned short tmp =0;//2字节
	 //temperature
	//s32 XIicPs_MasterSendPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	status = XIicPs_MasterSendPolled(&IicPs,&CmdTemp,0x01,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_MasterRecvPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	//数组就是指针类型的，不用取地址
	status = XIicPs_MasterRecvPolled(&IicPs,Tdata,0x02,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//先读出来高字节，放到0地址中
	//左移8位变成高八位，低八位为0.低8位就是Tdata[1]&0xFC.
	//将左括号低位补8个0，右括号中的数高位补8个0，按位或
	tmp=(Tdata[0]<<8) | (Tdata[1]&0xFC);
	Tout = (175.72*tmp/65536)-46.85;
	//Humidity
	//s32 XIicPs_MasterSendPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	status = XIicPs_MasterSendPolled(&IicPs,&CmdHum,0x01,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	//s32 XIicPs_MasterRecvPolled(XIicPs *InstancePtr, u8 *MsgPtr, s32 ByteCount,u16 SlaveAddr);
	//数组就是指针类型的，不用取地址
	status = XIicPs_MasterRecvPolled(&IicPs,Hdata,0x02,IIC_SLV_ADDR);
	if(status != XST_SUCCESS){
					return	XST_FAILURE;
	}
	tmp =(Hdata[0]<<8) | (Hdata[1]&0xFC);
	Hout = ((125*tmp)/65536) - 6;

	DataBuf[0]=Tout;
	DataBuf[1]=Hout;


}

```

# **第五讲、双核** **AMP** **非对称处理器架构程序开发**

ARM启动过程

arm中有一段小程序，收到管脚上的mio配置arm的工作模式的，（从sd卡加载、flash中加载、gtag程序）

板卡上的开关，一个指向gtag、一个指向sd卡

ram中有个rom存储空间，rom的存储空间不可改变。rom启动fsbl。加载bit或者elf。elf就是arm开发的应用程序。如果跑的是操作系统，elf替换为uboot。

![image-20231207104953918](H:/typora%E5%9B%BE%E7%89%87/image-20231207104953918.png)

fsbl有个模板，修改模板即可。然后完成cpu0和cpu1的搭建。

## 实验步骤

### 创建AMP_prj工程

![image-20231207105124387](H:/typora%E5%9B%BE%E7%89%87/image-20231207105124387.png)

![image-20231207105137884](H:/typora%E5%9B%BE%E7%89%87/image-20231207105137884.png)

![image-20231207105203163](H:/typora%E5%9B%BE%E7%89%87/image-20231207105203163.png)

![image-20231207105226068](H:/typora%E5%9B%BE%E7%89%87/image-20231207105226068.png)

设置核

PS-PL

![image-20231207105322220](H:/typora%E5%9B%BE%E7%89%87/image-20231207105322220.png)

MIO

配置电平

![image-20231207105413976](H:/typora%E5%9B%BE%E7%89%87/image-20231207105413976.png)

Clock

![image-20231207105441036](H:/typora%E5%9B%BE%E7%89%87/image-20231207105441036.png)

DDR跟前面配置一样

生成顶层

![image-20231207105609987](H:/typora%E5%9B%BE%E7%89%87/image-20231207105609987.png)

生成bit文件

![image-20231207105631211](H:/typora%E5%9B%BE%E7%89%87/image-20231207105631211.png)

![image-20231207105655724](H:/typora%E5%9B%BE%E7%89%87/image-20231207105655724.png)

### 打开SDK编译器

加载SDK

#### 创建amp_fsbl工程

创建 amp_fsbl 用于生成烧写镜像的时候加载 Core0 和 Core1 的代码。

![image-20231207105811686](H:/typora%E5%9B%BE%E7%89%87/image-20231207105811686.png)

文件模板选择FSBL

![image-20231207105831052](H:/typora%E5%9B%BE%E7%89%87/image-20231207105831052.png)

让fsbl加载cpu1的应用程序

在ug585-zynq-7000手册中

![image-20231207162128917](H:/typora%E5%9B%BE%E7%89%87/image-20231207162128917.png)



在main函数之上加入如下代码

```c
#define sev() __asm__("sev")
#define CPU1STARTADR 0xFFFFFFF0
#define CPU1STARTMEM 0x2000000
void StartCpu1(void)
{
	#if 1
	fsbl_printf(DEBUG_GENERAL,"FSBL: Write the address of the application for CPU 1 to 0xFFFFFFF0\n\r");
	Xil_Out32(CPU1STARTADR, CPU1STARTMEM);
	dmb(); //waits until write has finished
	fsbl_printf(DEBUG_GENERAL,"FSBL: Execute the SEV instruction to cause CPU 1 to wake up and jump to the application\n\r");
	sev();
	#endif
}
```

在 load 镜像位置加入如图代码

```c
StartCpu1();
```

#### 新建cpu0的应用程序

使用hello world模板

![image-20231207111217068](H:/typora%E5%9B%BE%E7%89%87/image-20231207111217068.png)

![image-20231207111233831](H:/typora%E5%9B%BE%E7%89%87/image-20231207111233831.png)

```c
 COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))
```

此变量可以通过映射 OCM 完成共享内存，此内存地址为 OCM3 最后一个 64K

将cpu0的main.c代码用如下替换

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#define COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))

int main()
{
	COMM_VAL=0;
	//Disable cache on OCM
	Xil_SetTlbAttributes(0xFFFF0000,0x14de2);
	while(1){
	 print("Hello World cpu0 \n\r");
	 COMM_VAL =1;
	 while(COMM_VAL == 1){

	 }
	}
	 return 0;
}
```

打开 SRC 目录存在文件 lscript.ld（分配cpu0和cpu1的文件） ，点击source 做如下修改 

CPU0 的代码空间改为 1E00000

其中  0x10000是DDR起始地址。从基地址偏移length都属于cpu0

```c
MEMORY
{
   ps7_ddr_0 : ORIGIN = 0x100000, LENGTH = 0x1E00000
   ps7_ram_0 : ORIGIN = 0x0, LENGTH = 0x30000
   ps7_ram_1 : ORIGIN = 0xFFFF0000, LENGTH = 0xFE00
}
```

#### 创建cpu1的应用程序

步骤如上，main函数代码为

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

#define COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))
int main()
{
	//Disable cache on OCM
	Xil_SetTlbAttributes(0xFFFF0000,0x14de2);
	while(1){
	while(COMM_VAL == 0){
	}
	print("Hello World cpu1 \n\r");
	sleep(2);
	COMM_VAL=0;
	}
	 return 0;
}
```

跟cpu0不会冲突

```c
MEMORY
{
   ps7_ddr_0 : ORIGIN = 0x2000000, LENGTH = 0x1F00000
   ps7_ram_0 : ORIGIN = 0x0, LENGTH = 0x30000
   ps7_ram_1 : ORIGIN = 0xFFFF0000, LENGTH = 0xFE00
}
```

#### 设置app_cpu1_bsp为

![image-20231207173710740](H:/typora%E5%9B%BE%E7%89%87/image-20231207173710740.png)

 添加  CPU1 的 BSP setting 为 AMP 模式 **-DUSE_AMP=1**

![image-20231207173739501](H:/typora%E5%9B%BE%E7%89%87/image-20231207173739501.png)

#### 在串口运行测试

让cpu0先debug一下，在debug时，将application中将cpu1也连接上。

打开SDK串口，让cpu0和cpu1交替工作，然后一直让它们运行。

#### 在xilinx中生成 boot.bin 文件

（更详细操作看PDF）

其中新建一个bootimages的文件夹，将app_cpu0.bif输出到此

将所有文件添加上生成imag

![image-20231207174200563](H:/typora%E5%9B%BE%E7%89%87/image-20231207174200563.png)

create boot image 添加文件时如果用的操作系统

![image-20231207170945675](H:/typora%E5%9B%BE%E7%89%87/image-20231207170945675.png)

创建完成后在此路径下有boot.bin

![image-20231207171134337](H:/typora%E5%9B%BE%E7%89%87/image-20231207171134337.png)

#### 拷入SD卡

插入SD卡，将原来的改为old，将新的复制进去，然后弹出SD卡

![image-20231207153922264](H:/typora%E5%9B%BE%E7%89%87/image-20231207153922264.png)

将此文件拷贝到SD卡中。

板卡断电，将SD卡插入板卡中，将开关拨到sd卡一侧

把 boot.bin 拷贝到 SD 板卡上电串口会交替打印如下信息，证明双核已经顺利启动。

![image-20231207174355310](H:/typora%E5%9B%BE%E7%89%87/image-20231207174355310.png)

#### 为何会交替打印

![image-20231207223346735](H:/typora%E5%9B%BE%E7%89%87/image-20231207223346735.png)

##   软中断的注册和使用

### ```app_intr_cpu0```

![image-20231207193348973](H:/typora%E5%9B%BE%E7%89%87/image-20231207193348973.png)

![image-20231207193440272](H:/typora%E5%9B%BE%E7%89%87/image-20231207193440272.png)

将cpu 0的main.c复制进来，修改

```c
#include <stdio.h>
#include "xil_printf.h"
#include "xscugic.h"
#include "xparameters.h"

#define COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))
#define GIC_ID XPAR_PS7_SCUGIC_0_DEVICE_ID
#define CPU0_SW_INTR 0x0d
#define CPU1_SW_INTR 0x0E

int initSwIntr();
void cpu0IntrHandler(void *CallBackRef);

static XScuGic ScuGic;
static XScuGic_Config *ScuGicCfgPtr;

int main()
{
	COMM_VAL=0;
	//Disable cache on OCM
	Xil_SetTlbAttributes(0xFFFF0000,0x14de2);
	int status;
	//初始化中断
	status=initSwIntr();
	if (status!=XST_SUCCESS){
		return status;
	}
	while(1){
	 print("Hello World cpu0 \n\r");
	 //允许软件在中断控制器中模拟中断。仅当中断控制器在模拟模式下启动时，此功能才会成功。
	 //模拟中断允许测试中断控制器，而无需任何设备将中断输入信号驱动到其中。
	 //CPU0工作中断CPU1。（，中断目标，指的使能对应的 CPU 会接收中断）
	 XScuGic_SoftwareIntr(&ScuGic,CPU1_SW_INTR,XSCUGIC_SPI_CPU1_MASK);
	 COMM_VAL =1;
	 while(COMM_VAL == 1){

	 }
	}
	 return 0;
}
//
int initSwIntr(){
	int status;
	Xil_ExceptionInit();
	//初始化中断控制器
	ScuGicCfgPtr=XScuGic_LookupConfig(GIC_ID);
	status=XScuGic_CfgInitialize(&ScuGic,ScuGicCfgPtr,ScuGicCfgPtr->CpuBaseAddress);
	if (status!=XST_SUCCESS){
		return status;
	}
	//注册异常处理回调函数到CPU
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,&ScuGic);
	//连接软中断中断信号并注册软中断回调函数 中断cpu0
	//中断源ID
	status=XScuGic_Connect(&ScuGic,CPU0_SW_INTR,(Xil_InterruptHandler)cpu0IntrHandler,(void *)&ScuGic);
	if (status!=XST_SUCCESS){
		return status;
	}
	XScuGic_Enable(&ScuGic,CPU0_SW_INTR);
	Xil_ExceptionEnable();
	return XST_SUCCESS;
}
//cpu0被中断
void cpu0IntrHandler(void *CallBackRef){
	printf("cpu1 interrupt cpu0 !\n\r");
}

```

将iscript的地址也改为跟cpu 0一样

### ```app_intr_cpu1```

![image-20231207202014068](H:/typora%E5%9B%BE%E7%89%87/image-20231207202014068.png)

```c
#include <stdio.h>
#include "xil_printf.h"
#include "xscugic.h"
#include "xparameters.h"

#define COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))
#define GIC_ID XPAR_PS7_SCUGIC_0_DEVICE_ID
#define CPU0_SW_INTR 0x0d
#define CPU1_SW_INTR 0x0E

int initSwIntr();
void cpu1IntrHandler(void *CallBackRef);

static XScuGic ScuGic;
static XScuGic_Config *ScuGicCfgPtr;

int main()
{
	COMM_VAL=0;
	//Disable cache on OCM
	Xil_SetTlbAttributes(0xFFFF0000,0x14de2);
	int status;
	//初始化中断
	status=initSwIntr();
	if (status!=XST_SUCCESS){
		return status;
	}
	while(1){
	 print("Hello World cpu1 \n\r");
	 //允许软件在中断控制器中模拟中断。仅当中断控制器在模拟模式下启动时，此功能才会成功。
	 //模拟中断允许测试中断控制器，而无需任何设备将中断输入信号驱动到其中。
	 //cpu1工作中断CPU0。（，中断目标，指的使能对应的 CPU 会接收中断）
	 XScuGic_SoftwareIntr(&ScuGic,CPU0_SW_INTR,XSCUGIC_SPI_CPU0_MASK);
	 COMM_VAL =0;
	 sleep(2);
	 while(COMM_VAL == 0){

	 }
	}
	 return 0;
}
//
int initSwIntr(){
	int status;
	Xil_ExceptionInit();
	//初始化中断控制器
	ScuGicCfgPtr=XScuGic_LookupConfig(GIC_ID);
	status=XScuGic_CfgInitialize(&ScuGic,ScuGicCfgPtr,ScuGicCfgPtr->CpuBaseAddress);
	if (status!=XST_SUCCESS){
		return status;
	}
	//注册异常处理回调函数到CPU
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,&ScuGic);
	//连接软中断中断信号并注册软中断回调函数 中断cpu1
	//中断源ID
	status=XScuGic_Connect(&ScuGic,CPU1_SW_INTR,(Xil_InterruptHandler)cpu1IntrHandler,(void *)&ScuGic);
	if (status!=XST_SUCCESS){
		return status;
	}
	XScuGic_Enable(&ScuGic,CPU1_SW_INTR);
	Xil_ExceptionEnable();
	return XST_SUCCESS;
}
//cpu1被中断
void cpu1IntrHandler(void *CallBackRef){
	printf("cpu0 interrupt cpu1 !\n\r");
}

```

将iscript的地址也改为跟cpu 1一样

![image-20231207202424577](H:/typora%E5%9B%BE%E7%89%87/image-20231207202424577.png)

### 剩余实验步骤

添加  CPU1 的 BSP setting 为 AMP 模式 **-DUSE_AMP=1**

将板卡开关拨到JTAG

![image-20231207202650796](H:/typora%E5%9B%BE%E7%89%87/image-20231207202650796.png)

启动cpu0，单步运行cpu1，然后直接都运行

固化到SD卡中

![image-20231207204256279](H:/typora%E5%9B%BE%E7%89%87/image-20231207204256279.png)

通过串口输出

![image-20231207222207445](H:/typora%E5%9B%BE%E7%89%87/image-20231207222207445.png)

### 问题

在cpu0中```XScuGic_SoftwareIntr``，调用了cpu1项目中的中断？

![image-20231207223729282](H:/typora%E5%9B%BE%E7%89%87/image-20231207223729282.png)
